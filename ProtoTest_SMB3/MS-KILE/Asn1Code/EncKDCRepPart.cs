// 
// This file was generated by the Objective Systems ASN1C Compiler
// (http://www.obj-sys.com).  Version: 6.07, Date: 03-Sep-2009.
// 
using System;
using Com.Objsys.Asn1.Runtime;

namespace Microsoft.Protocols.TestTools.StackSdk.Security.Kile {

   public class EncKDCRepPart : Asn1Type {
      public EncryptionKey key;
      public LastReq last_req;
      public UInt32 nonce;
      public KerberosTime key_expiration;  // optional
      public TicketFlags flags;
      public KerberosTime authtime;
      public KerberosTime starttime;  // optional
      public KerberosTime endtime;
      public KerberosTime renew_till;  // optional
      public Realm srealm;
      public PrincipalName sname;
      public HostAddresses caddr;  // optional
      public PA_DATAS pa_datas;  // optional

      public EncKDCRepPart () : base()
      {
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor sets all elements to references to the 
      /// given objects
      /// </summary>
      public EncKDCRepPart (
         EncryptionKey key_,
         LastReq last_req_,
         UInt32 nonce_,
         KerberosTime key_expiration_,
         TicketFlags flags_,
         KerberosTime authtime_,
         KerberosTime starttime_,
         KerberosTime endtime_,
         KerberosTime renew_till_,
         Realm srealm_,
         PrincipalName sname_,
         HostAddresses caddr_,
         PA_DATAS pa_datas_
      )
         : base ()
      {
         key = key_;
         last_req = last_req_;
         nonce = nonce_;
         key_expiration = key_expiration_;
         flags = flags_;
         authtime = authtime_;
         starttime = starttime_;
         endtime = endtime_;
         renew_till = renew_till_;
         srealm = srealm_;
         sname = sname_;
         caddr = caddr_;
         pa_datas = pa_datas_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor is for required elements only.  It sets 
      /// all elements to references to the given objects
      /// </summary>
      public EncKDCRepPart (
         EncryptionKey key_,
         LastReq last_req_,
         UInt32 nonce_,
         TicketFlags flags_,
         KerberosTime authtime_,
         KerberosTime endtime_,
         Realm srealm_,
         PrincipalName sname_
      )
         : base ()
      {
         key = key_;
         last_req = last_req_;
         nonce = nonce_;
         flags = flags_;
         authtime = authtime_;
         endtime = endtime_;
         srealm = srealm_;
         sname = sname_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor allows primitive data to be passed for all 
      /// primitive elements.  It will create new object wrappers for 
      /// the primitive data and set other elements to references to 
      /// the given objects 
      /// </summary>
      public EncKDCRepPart (EncryptionKey key_,
         LastReq last_req_,
         long nonce_,
         string key_expiration_,
         TicketFlags flags_,
         string authtime_,
         string starttime_,
         string endtime_,
         string renew_till_,
         string srealm_,
         PrincipalName sname_,
         HostAddresses caddr_,
         PA_DATAS pa_datas_
      )
         : base ()
      {
         key = key_;
         last_req = last_req_;
         nonce = new UInt32 (nonce_);
         key_expiration = new KerberosTime (key_expiration_);
         flags = flags_;
         authtime = new KerberosTime (authtime_);
         starttime = new KerberosTime (starttime_);
         endtime = new KerberosTime (endtime_);
         renew_till = new KerberosTime (renew_till_);
         srealm = new Realm (srealm_);
         sname = sname_;
         caddr = caddr_;
         pa_datas = pa_datas_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor is for required elements only.  It allows 
      /// primitive data to be passed for all primitive elements.  
      /// It will create new object wrappers for the primitive data 
      /// and set other elements to references to the given objects. 
      /// </summary>
      public EncKDCRepPart (
         EncryptionKey key_,
         LastReq last_req_,
         long nonce_,
         TicketFlags flags_,
         string authtime_,
         string endtime_,
         string srealm_,
         PrincipalName sname_
      )
         : base ()
      {
         key = key_;
         last_req = last_req_;
         nonce = new UInt32 (nonce_);
         flags = flags_;
         authtime = new KerberosTime (authtime_);
         endtime = new KerberosTime (endtime_);
         srealm = new Realm (srealm_);
         sname = sname_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      public void Init () {
         key = null;
         last_req = null;
         nonce = null;
         key_expiration = null;
         flags = null;
         authtime = null;
         starttime = null;
         endtime = null;
         renew_till = null;
         srealm = null;
         sname = null;
         caddr = null;
         pa_datas = null;
      }

      public override void Decode
         (Asn1BerDecodeBuffer buffer, bool explicitTagging, int implicitLength)
      {
         int llen = (explicitTagging) ?
            MatchTag (buffer, Asn1Tag.SEQUENCE) : implicitLength;

         Init ();

         // decode SEQUENCE

         Asn1BerDecodeContext _context =
            new Asn1BerDecodeContext (buffer, llen);

         IntHolder elemLen = new IntHolder();

         // decode key

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 0, elemLen, true)) {
            key = new EncryptionKey();
            key.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode last_req

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 1, elemLen, true)) {
            last_req = new LastReq();
            last_req.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode nonce

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 2, elemLen, true)) {
            nonce = new UInt32();
            nonce.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode key_expiration

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 3, elemLen, true)) {
            key_expiration = new KerberosTime();
            key_expiration.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode flags

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 4, elemLen, true)) {
            flags = new TicketFlags();
            flags.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode authtime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 5, elemLen, true)) {
            authtime = new KerberosTime();
            authtime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode starttime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 6, elemLen, true)) {
            starttime = new KerberosTime();
            starttime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode endtime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 7, elemLen, true)) {
            endtime = new KerberosTime();
            endtime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode renew_till

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 8, elemLen, true)) {
            renew_till = new KerberosTime();
            renew_till.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode srealm

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 9, elemLen, true)) {
            srealm = new Realm();
            srealm.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode sname

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 10, elemLen, true)) {
            sname = new PrincipalName();
            sname.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode caddr

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 11, elemLen, true)) {
            caddr = new HostAddresses();
            caddr.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode pa_datas

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 12, elemLen, true)) {
            pa_datas = new PA_DATAS();
            pa_datas.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         if (explicitTagging && llen == Asn1Status.INDEFLEN) {
            MatchTag (buffer, Asn1Tag.EOC);
         }
      }

      public override int Encode (Asn1BerEncodeBuffer buffer, bool explicitTagging)
      {
         int _aal = 0, len;

         // encode pa_datas

         if (pa_datas != null) {
            len = pa_datas.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 12, len);
            _aal += len;
         }

         // encode caddr

         if (caddr != null) {
            len = caddr.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 11, len);
            _aal += len;
         }

         // encode sname

         len = sname.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 10, len);
         _aal += len;

         // encode srealm

         len = srealm.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 9, len);
         _aal += len;

         // encode renew_till

         if (renew_till != null) {
            len = renew_till.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 8, len);
            _aal += len;
         }

         // encode endtime

         len = endtime.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 7, len);
         _aal += len;

         // encode starttime

         if (starttime != null) {
            len = starttime.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 6, len);
            _aal += len;
         }

         // encode authtime

         len = authtime.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 5, len);
         _aal += len;

         // encode flags

         len = flags.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 4, len);
         _aal += len;

         // encode key_expiration

         if (key_expiration != null) {
            len = key_expiration.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 3, len);
            _aal += len;
         }

         // encode nonce

         len = nonce.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 2, len);
         _aal += len;

         // encode last_req

         len = last_req.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 1, len);
         _aal += len;

         // encode key

         len = key.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 0, len);
         _aal += len;

         if (explicitTagging) {
            _aal += buffer.EncodeTagAndLength (Asn1Tag.SEQUENCE, _aal);
         }

         return (_aal);
      }

   }
}
