// 
// This file was generated by the Objective Systems ASN1C Compiler
// (http://www.obj-sys.com).  Version: 6.10, Date: 01-Jul-2008.
// 
using System;
using Com.Objsys.Asn1.Runtime;

namespace Microsoft.Protocols.TestTools.StackSdk.Security.Kile {

   public class KDC_REQ_BODY : Asn1Type {
      public KDCOptions kdc_options;
      public PrincipalName cname;  // optional
      public Realm realm;
      public PrincipalName sname;  // optional
      public KerberosTime from;  // optional
      public KerberosTime till;
      public KerberosTime rtime;  // optional
      public UInt32 nonce;
      public _SeqOfInt32 etype;
      public HostAddresses addresses;  // optional
      public EncryptedData enc_authorization_data;  // optional
      public _SeqOfTicket additional_tickets;  // optional

      public KDC_REQ_BODY () : base()
      {
         Init();
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor sets all elements to references to the 
      /// given objects
      /// </summary>
      public KDC_REQ_BODY (
         KDCOptions kdc_options_,
         PrincipalName cname_,
         Realm realm_,
         PrincipalName sname_,
         KerberosTime from_,
         KerberosTime till_,
         KerberosTime rtime_,
         UInt32 nonce_,
         _SeqOfInt32 etype_,
         HostAddresses addresses_,
         EncryptedData enc_authorization_data_,
         _SeqOfTicket additional_tickets_
      )
         : base ()
      {
         kdc_options = kdc_options_;
         cname = cname_;
         realm = realm_;
         sname = sname_;
         from = from_;
         till = till_;
         rtime = rtime_;
         nonce = nonce_;
         etype = etype_;
         addresses = addresses_;
         enc_authorization_data = enc_authorization_data_;
         additional_tickets = additional_tickets_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor is for required elements only.  It sets 
      /// all elements to references to the given objects
      /// </summary>
      public KDC_REQ_BODY (
         KDCOptions kdc_options_,
         Realm realm_,
         KerberosTime till_,
         UInt32 nonce_,
         _SeqOfInt32 etype_
      )
         : base ()
      {
         kdc_options = kdc_options_;
         realm = realm_;
         till = till_;
         nonce = nonce_;
         etype = etype_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor allows primitive data to be passed for all 
      /// primitive elements.  It will create new object wrappers for 
      /// the primitive data and set other elements to references to 
      /// the given objects 
      /// </summary>
      public KDC_REQ_BODY (KDCOptions kdc_options_,
         PrincipalName cname_,
         string realm_,
         PrincipalName sname_,
         string from_,
         string till_,
         string rtime_,
         long nonce_,
         _SeqOfInt32 etype_,
         HostAddresses addresses_,
         EncryptedData enc_authorization_data_,
         _SeqOfTicket additional_tickets_
      )
         : base ()
      {
         kdc_options = kdc_options_;
         cname = cname_;
         realm = new Realm (realm_);
         sname = sname_;
         from = new KerberosTime (from_);
         till = new KerberosTime (till_);
         rtime = new KerberosTime (rtime_);
         nonce = new UInt32 (nonce_);
         etype = etype_;
         addresses = addresses_;
         enc_authorization_data = enc_authorization_data_;
         additional_tickets = additional_tickets_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor is for required elements only.  It allows 
      /// primitive data to be passed for all primitive elements.  
      /// It will create new object wrappers for the primitive data 
      /// and set other elements to references to the given objects. 
      /// </summary>
      public KDC_REQ_BODY (
         KDCOptions kdc_options_,
         string realm_,
         string till_,
         long nonce_,
         _SeqOfInt32 etype_
      )
         : base ()
      {
         kdc_options = kdc_options_;
         realm = new Realm (realm_);
         till = new KerberosTime (till_);
         nonce = new UInt32 (nonce_);
         etype = etype_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      public void Init () {
         kdc_options = null;
         cname = null;
         realm = null;
         sname = null;
         from = null;
         till = null;
         rtime = null;
         nonce = null;
         etype = null;
         addresses = null;
         enc_authorization_data = null;
         additional_tickets = null;
      }

      public override void Decode
         (Asn1BerDecodeBuffer buffer, bool explicitTagging, int implicitLength)
      {
         int llen = (explicitTagging) ?
            MatchTag (buffer, Asn1Tag.SEQUENCE) : implicitLength;

         Init ();

         // decode SEQUENCE

         Asn1BerDecodeContext _context =
            new Asn1BerDecodeContext (buffer, llen);

         IntHolder elemLen = new IntHolder();

         // decode kdc_options

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 0, elemLen, true)) {
            kdc_options = new KDCOptions();
            kdc_options.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode cname

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 1, elemLen, true)) {
            cname = new PrincipalName();
            cname.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode realm

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 2, elemLen, true)) {
            realm = new Realm();
            realm.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode sname

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 3, elemLen, true)) {
            sname = new PrincipalName();
            sname.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode from

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 4, elemLen, true)) {
            from = new KerberosTime();
            from.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode till

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 5, elemLen, true)) {
            till = new KerberosTime();
            till.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode rtime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 6, elemLen, true)) {
            rtime = new KerberosTime();
            rtime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode nonce

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 7, elemLen, true)) {
            nonce = new UInt32();
            nonce.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode etype

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 8, elemLen, true)) {
            etype = new _SeqOfInt32();
            etype.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode addresses

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 9, elemLen, true)) {
            addresses = new HostAddresses();
            addresses.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode enc_authorization_data

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 10, elemLen, true)) {
            enc_authorization_data = new EncryptedData();
            enc_authorization_data.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode additional_tickets

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 11, elemLen, true)) {
            additional_tickets = new _SeqOfTicket();
            additional_tickets.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         if (explicitTagging && llen == Asn1Status.INDEFLEN) {
            MatchTag (buffer, Asn1Tag.EOC);
         }
      }

      public override int Encode (Asn1BerEncodeBuffer buffer, bool explicitTagging)
      {
         int _aal = 0, len;

         // encode additional_tickets

         if (additional_tickets != null) {
            len = additional_tickets.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 11, len);
            _aal += len;
         }

         // encode enc_authorization_data

         if (enc_authorization_data != null) {
            len = enc_authorization_data.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 10, len);
            _aal += len;
         }

         // encode addresses

         if (addresses != null) {
            len = addresses.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 9, len);
            _aal += len;
         }

         // encode etype

         len = etype.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 8, len);
         _aal += len;

         // encode nonce

         len = nonce.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 7, len);
         _aal += len;

         // encode rtime

         if (rtime != null) {
            len = rtime.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 6, len);
            _aal += len;
         }

         // encode till

         len = till.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 5, len);
         _aal += len;

         // encode from

         if (from != null) {
            len = from.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 4, len);
            _aal += len;
         }

         // encode sname

         if (sname != null) {
            len = sname.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 3, len);
            _aal += len;
         }

         // encode realm

         len = realm.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 2, len);
         _aal += len;

         // encode cname

         if (cname != null) {
            len = cname.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 1, len);
            _aal += len;
         }

         // encode kdc_options

         len = kdc_options.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 0, len);
         _aal += len;

         if (explicitTagging) {
            _aal += buffer.EncodeTagAndLength (Asn1Tag.SEQUENCE, _aal);
         }

         return (_aal);
      }

   }
}
