// 
// This file was generated by the Objective Systems ASN1C Compiler
// (http://www.obj-sys.com).  Version: 6.10, Date: 01-Jul-2008.
// 
using System;
using Com.Objsys.Asn1.Runtime;

namespace Microsoft.Protocols.TestTools.StackSdk.Security.Kile {

   public class KrbCredInfo : Asn1Type {
      public EncryptionKey key;
      public Realm prealm;  // optional
      public PrincipalName pname;  // optional
      public TicketFlags flags;  // optional
      public KerberosTime authtime;  // optional
      public KerberosTime starttime;  // optional
      public KerberosTime endtime;  // optional
      public KerberosTime renew_till;  // optional
      public Realm srealm;  // optional
      public PrincipalName sname;  // optional
      public HostAddresses caddr;  // optional

      public KrbCredInfo () : base()
      {
         Init();
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor sets all elements to references to the 
      /// given objects
      /// </summary>
      public KrbCredInfo (
         EncryptionKey key_,
         Realm prealm_,
         PrincipalName pname_,
         TicketFlags flags_,
         KerberosTime authtime_,
         KerberosTime starttime_,
         KerberosTime endtime_,
         KerberosTime renew_till_,
         Realm srealm_,
         PrincipalName sname_,
         HostAddresses caddr_
      )
         : base ()
      {
         key = key_;
         prealm = prealm_;
         pname = pname_;
         flags = flags_;
         authtime = authtime_;
         starttime = starttime_;
         endtime = endtime_;
         renew_till = renew_till_;
         srealm = srealm_;
         sname = sname_;
         caddr = caddr_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor is for required elements only.  It sets 
      /// all elements to references to the given objects
      /// </summary>
      public KrbCredInfo (
         EncryptionKey key_
      )
         : base ()
      {
         key = key_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      /// <summary>
      /// This constructor allows primitive data to be passed for all 
      /// primitive elements.  It will create new object wrappers for 
      /// the primitive data and set other elements to references to 
      /// the given objects 
      /// </summary>
      public KrbCredInfo (EncryptionKey key_,
         string prealm_,
         PrincipalName pname_,
         TicketFlags flags_,
         string authtime_,
         string starttime_,
         string endtime_,
         string renew_till_,
         string srealm_,
         PrincipalName sname_,
         HostAddresses caddr_
      )
         : base ()
      {
         key = key_;
         prealm = new Realm (prealm_);
         pname = pname_;
         flags = flags_;
         authtime = new KerberosTime (authtime_);
         starttime = new KerberosTime (starttime_);
         endtime = new KerberosTime (endtime_);
         renew_till = new KerberosTime (renew_till_);
         srealm = new Realm (srealm_);
         sname = sname_;
         caddr = caddr_;
         SetKey (_KerberosV5Spec2Values._rtkey);
      }

      public void Init () {
         key = null;
         prealm = null;
         pname = null;
         flags = null;
         authtime = null;
         starttime = null;
         endtime = null;
         renew_till = null;
         srealm = null;
         sname = null;
         caddr = null;
      }

      public override void Decode
         (Asn1BerDecodeBuffer buffer, bool explicitTagging, int implicitLength)
      {
         int llen = (explicitTagging) ?
            MatchTag (buffer, Asn1Tag.SEQUENCE) : implicitLength;

         Init ();

         // decode SEQUENCE

         Asn1BerDecodeContext _context =
            new Asn1BerDecodeContext (buffer, llen);

         IntHolder elemLen = new IntHolder();

         // decode key

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 0, elemLen, true)) {
            key = new EncryptionKey();
            key.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode prealm

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 1, elemLen, true)) {
            prealm = new Realm();
            prealm.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode pname

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 2, elemLen, true)) {
            pname = new PrincipalName();
            pname.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode flags

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 3, elemLen, true)) {
            flags = new TicketFlags();
            flags.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode authtime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 4, elemLen, true)) {
            authtime = new KerberosTime();
            authtime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode starttime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 5, elemLen, true)) {
            starttime = new KerberosTime();
            starttime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode endtime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 6, elemLen, true)) {
            endtime = new KerberosTime();
            endtime.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode renew_till

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 7, elemLen, true)) {
            renew_till = new KerberosTime();
            renew_till.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode srealm

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 8, elemLen, true)) {
            srealm = new Realm();
            srealm.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode sname

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 9, elemLen, true)) {
            sname = new PrincipalName();
            sname.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         // decode caddr

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 10, elemLen, true)) {
            caddr = new HostAddresses();
            caddr.Decode (buffer, true, elemLen.mValue);
            if (elemLen.mValue == Asn1Status.INDEFLEN) {
               MatchTag (buffer, Asn1Tag.EOC);
            }
         }

         if (explicitTagging && llen == Asn1Status.INDEFLEN) {
            MatchTag (buffer, Asn1Tag.EOC);
         }
      }

      public override int Encode (Asn1BerEncodeBuffer buffer, bool explicitTagging)
      {
         int _aal = 0, len;

         // encode caddr

         if (caddr != null) {
            len = caddr.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 10, len);
            _aal += len;
         }

         // encode sname

         if (sname != null) {
            len = sname.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 9, len);
            _aal += len;
         }

         // encode srealm

         if (srealm != null) {
            len = srealm.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 8, len);
            _aal += len;
         }

         // encode renew_till

         if (renew_till != null) {
            len = renew_till.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 7, len);
            _aal += len;
         }

         // encode endtime

         if (endtime != null) {
            len = endtime.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 6, len);
            _aal += len;
         }

         // encode starttime

         if (starttime != null) {
            len = starttime.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 5, len);
            _aal += len;
         }

         // encode authtime

         if (authtime != null) {
            len = authtime.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 4, len);
            _aal += len;
         }

         // encode flags

         if (flags != null) {
            len = flags.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 3, len);
            _aal += len;
         }

         // encode pname

         if (pname != null) {
            len = pname.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 2, len);
            _aal += len;
         }

         // encode prealm

         if (prealm != null) {
            len = prealm.Encode (buffer, true);
            _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 1, len);
            _aal += len;
         }

         // encode key

         len = key.Encode (buffer, true);
         _aal += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 0, len);
         _aal += len;

         if (explicitTagging) {
            _aal += buffer.EncodeTagAndLength (Asn1Tag.SEQUENCE, _aal);
         }

         return (_aal);
      }

   }
}
